// 有線音樂控制器 (基於RFID邏輯)
#include <SPI.h>
#include <MFRC522.h>

// 定義 RFID 感測器的腳位
#define RST_PIN     22    // RST 連接到 GPIO 22
#define SS_PIN      21    // SDA(SS) 連接到 GPIO 21

// 建立 RFID 物件
MFRC522 rfid(SS_PIN, RST_PIN);

// 記錄目前感應的卡片類型 (0=無卡片, 1=卡片1, 2=卡片2, 3=卡片3)
int currentCard = 0;

// 檢測卡片移開的計數器
int missingCount = 0;

// 定義三張卡片的 UID (以十六進制表示)
// 請更換為您實際卡片的 UID
byte card1UID[4] = {0x0B, 0x1D, 0x2D, 0x05}; // 第一張卡片的UID
byte card2UID[4] = {0xA1, 0x8B, 0x28, 0x05}; // 第二張卡片的UID
byte card3UID[4] = {0x33, 0xA7, 0xB3, 0x1B}; // 第三張卡片的UID

void setup() {
  Serial.begin(9600);
  SPI.begin();         // 初始化 SPI 總線
  rfid.PCD_Init();     // 初始化 RFID 感測器
  
  Serial.println("RFID 有線音樂控制器已啟動");
}

void loop() {
  // 如果先前沒有卡片
  if (currentCard == 0) {
    // 檢查是否有新卡片
    if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
      // 讀取卡片UID
      Serial.print("偵測到卡片 UID: ");
      printHex(rfid.uid.uidByte, rfid.uid.size);
      
      // 檢查是哪一張卡片
      int cardType = checkCardType(rfid.uid.uidByte, rfid.uid.size);
      
      if (cardType > 0) {
        currentCard = cardType;
        
        Serial.print("偵測到卡片 ");
        Serial.println(currentCard);
        if(currentCard == 1)
          Serial.println("PLAY_MUSIC_1");
        else if(currentCard == 2)
          Serial.println("PLAY_MUSIC_2");
        else if(currentCard == 3)
          Serial.println("PLAY_MUSIC_3");  
      } else {
        Serial.println("偵測到無效卡片");
      }
      
      // 停止讀取目前的卡片
      rfid.PICC_HaltA();
      rfid.PCD_StopCrypto1();
    }
  } 
  // 如果先前有卡片，檢查卡片是否移開
  else {
    // 嘗試重新啟動通訊
    rfid.PCD_Init();  // 重新初始化讀卡器
    delay(10);        // 短暫延遲
    
    // 嘗試偵測卡片
    if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
      // 卡片仍然存在，檢查是否為同一張卡
      int cardType = checkCardType(rfid.uid.uidByte, rfid.uid.size);
      
      if (cardType == currentCard) {
        // 還是同一張卡，重置計數器
        missingCount = 0;
      } else {
        // 是另一張卡，先發送停止命令
        Serial.println("STOP_MUSIC");
        
        // 然後更新當前卡片類型並發送新的播放命令
        currentCard = cardType;
        
        if (cardType > 0) {
          Serial.print("卡片已更換為卡片 ");
          Serial.println(currentCard);
          
        if(currentCard == 1)
          Serial.println("PLAY_MUSIC_1");
        else if(currentCard == 2)
          Serial.println("PLAY_MUSIC_2");
        else if(currentCard == 3)
          Serial.println("PLAY_MUSIC_3");
        } else {
          // 無效卡片，視為卡片已移開
          currentCard = 0;
          Serial.println("卡片已移開或更換為無效卡片");
        }
      }
      
      // 停止讀取目前的卡片
      rfid.PICC_HaltA();
      rfid.PCD_StopCrypto1();
    } else {
      // 沒有偵測到卡片，增加計數器
      missingCount++;
      
      // 只有在連續多次未檢測到卡片時才判定卡片已移開
      // 這裡設為5次，您可以根據實際情況調整
      if (missingCount >= 1) {
        int lastCard = currentCard;
        currentCard = 0;
        missingCount = 0;
        
        Serial.println("卡片已移開");
        
        // 發送停止命令
        Serial.println("STOP_MUSIC");
      }
    }
  }
  
  delay(100);  // 短暫延遲
}

// 檢查卡片類型 (返回1=卡片1, 2=卡片2, 3=卡片3, 0=無效卡片)
int checkCardType(byte *uid, byte size) {
  if (size != 4) return 0; // UID長度必須為4
  
  // 檢查是否是卡片1
  bool isCard1 = true;
  for (byte i = 0; i < 4; i++) {
    if (uid[i] != card1UID[i]) {
      isCard1 = false;
      break;
    }
  }
  if (isCard1) return 1;
  
  // 檢查是否是卡片2
  bool isCard2 = true;
  for (byte i = 0; i < 4; i++) {
    if (uid[i] != card2UID[i]) {
      isCard2 = false;
      break;
    }
  }
  if (isCard2) return 2;
  
  // 檢查是否是卡片3
  bool isCard3 = true;
  for (byte i = 0; i < 4; i++) {
    if (uid[i] != card3UID[i]) {
      isCard3 = false;
      break;
    }
  }
  if (isCard3) return 3;
  
  // 如果都不是，則為無效卡片
  return 0;
}

// 輔助函數：將 UID 轉換為十六進制字串
void printHex(byte *buffer, byte bufferSize) {
  for (byte i = 0; i < bufferSize; i++) {
    Serial.print(buffer[i] < 0x10 ? " 0" : " ");
    Serial.print(buffer[i], HEX);
  }
  Serial.println();
}